/*
 * Holodos Telegram Bot
 * Copyright(c) 2022 Dmitrii Baklai
 * MIT Licensed
 */
process.env.NTBA_FIX_319 = 1;

const consola = require('consola');
const express = require('express');
const mongoose = require('mongoose');
const TelegramBot = require('node-telegram-bot-api');
const User = require('./services/user.service');
const Catalog = require('./services/catalog.service');

const { TELEGRAM_TOKEN, MONGO_URL, PROXY_SERVER, APP_URL } = process.env;

mongoose
  .connect(MONGO_URL, {
    useNewUrlParser: true,
    useUnifiedTopology: true
  })
  .then(() => {
    consola.info('Success MongoDB connected');
  })
  .catch((err) => {
    consola.error('Failed to connect to MongoDB', err);
    process.exit(0);
  });

const app = express();

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

const optionsPolling = {
  filepath: false,
  polling: {
    interval: 300,
    autoStart: true,
    params: { timeout: 10 }
  },
  request: {
    proxy: PROXY_SERVER ? PROXY_SERVER : null
  }
};

const bot = new TelegramBot(
  TELEGRAM_TOKEN,
  process.env.NODE_ENV === 'production' ? {} : optionsPolling
);

if (process.env.NODE_ENV === 'production') {
  bot.setWebHook(`${APP_URL}/bot/v1/bot${TELEGRAM_TOKEN}`);
} else {
  bot.on('polling_error', function (err) {
    consola.error(err.code);
  });
}

const commands = [{ command: 'start', description: '—Å—Ç–∞—Ä—Ç' }];

bot
  .setMyCommands([...commands], {})
  .then(function (msg) {
    msg ? consola.info('Telegram Bot is running...') : process.exit(1);
  })
  .catch((err) => {
    consola.error(err.code);
    consola.error(err.response);
    process.exit(1);
  });

bot.onText(/\/start/, async (msg) => {
  const { id } = msg.chat;
  const html = `<b>–í—ñ—Ç–∞–Ω–Ω—è <i>${msg.from.first_name}</i></b>!\n\n<i>–Ø –¥–æ–ø–æ–º–æ–∂—É –∑—Ä–æ–±–∏—Ç–∏ –ø—Ä–æ—Ü–µ—Å –ø–æ—Ö–æ–¥—É –≤ –º–∞–≥–∞–∑–∏–Ω –ø—Ä–æ—Å—Ç—ñ—à–µ, —à–≤–∏–¥—à–µ, —ñ –Ω–∞–π–≥–æ–ª–æ–≤–Ω—ñ—à–µ, –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—à–µ.</i>\n\n–í—ñ–¥–∫—Ä–∏–π —Ö–æ–ª–æ–¥–æ—Å, —â–æ–± –ø–æ—á–∞—Ç–∏ üëá`;

  bot
    .sendMessage(id, html, {
      parse_mode: 'HTML',
      reply_markup: {
        keyboard: [
          [
            {
              text: 'üçéüçâü•ë –í—ñ–¥–∫—Ä–∏—Ç–∏ —Ö–æ–ª–æ–¥–æ—Å üçäü•©üçÜ',
              web_app: { url: APP_URL }
            }
          ]
        ],
        resize_keyboard: true
      }
    })
    .catch((err) => {
      consola.error(err.code);
      consola.error(err.response.body);
    });

  await User.createOne(msg.chat);
});

bot.on('web_app_data', async (msg) => {
  const { products, price, comment } = JSON.parse(msg.web_app_data.data);

  if (products.length > 0) {
    let html = 'üîñ <b>–í–∞—à —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤:</b>\n\n';
    products.forEach((el, index) => {
      html += `<b>${index + 1}</b>. ${el.title} (${el.counter}x) - <i>${
        el.price
      } ${el.priceTitle}</i>\n`;
    });

    price ? (html += `\n<b>–í–°–¨–û–ì–û:</b> ‚Ç¥${price}`) : (html += '');

    comment
      ? (html += `\n<b>–í–∞—à –∫–æ–º–µ–Ω—Ç–∞—Ä:</b> <i>${comment}</i>`)
      : (html += '');

    bot
      .sendMessage(msg.chat.id, html, {
        parse_mode: 'HTML'
      })
      .catch((err) => {
        consola.error(err.code);
        consola.error(err.response.body);
      });
  } else {
    let html = 'üó£ <b>–í–∞—à —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ –ø–æ—Ä–æ–∂–Ω—ñ–π!</b>';
    bot.sendMessage(msg.chat.id, html, { parse_mode: 'HTML' }).catch((err) => {
      consola.error(err.code);
      consola.error(err.response.body);
    });
  }

  await User.createOne(msg.chat);
});

app.post(`/bot${TELEGRAM_TOKEN}`, (req, res) => {
  bot.processUpdate(req.body);
  res.sendStatus(200);
});

app.get('/catalog', async (req, res, next) => {
  try {
    const items = await Catalog.all–°atalog();
    res.status(200).json(items);
  } catch (err) {
    next(err);
  }
});

app.get('/catalog/:id', async (req, res, next) => {
  try {
    const { id } = req.params;
    const items = await Catalog.one–°atalog(id);
    res.status(200).json(items);
  } catch (err) {
    next(err);
  }
});

app.use((req, res, next) => {
  res.status(404).json({ message: 'Oops! Error 404 has occurred' });
});

app.use((err, req, res, next) => {
  res.status(500).json({ message: 'Oops! Internal server error' });
});

consola.info('Bot server success is running');

module.exports = app;
